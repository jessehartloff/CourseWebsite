---
title: Data Structures
short_title: ds
next_content_short: files
previous_content_short: functions
---


[Monday - Using ArrayList including as input to their method (unknown number of unknown values!)]
[Wednesday - Using Map]
[Friday - For-each]


{#== Data Structures#}
{##}
{#Slides? (I don't have a lot of individual things. I have a group of things. This is my collection of video games.#}
{#I can perform acts on my things. I clean all my dishes. I don't say I clean plate1, plate2, plate3, spoon1, spoon2, etc.#}
{#I clean my collection of nameless dishes. I launder all my clothes. While I some plates with certain scratches that I#}
{#recognize, I don't name each one as we would with variables. I just have plates. Sometimes they do all have names but we#}
{#to do something to all of them anyway. This class has 32 named TAs and sometimes you want to ask all of them a question#}
{#on the question site to maximize the chance of a quick response.)#}
{##}
{#When we want to store multiple related values.#}
{##}
{#Don't know how many we want to store.#}
{##}
{#Even if we know, what if we need to store 10000 values? Declare 10000 variables all with different names?#}


== Import


<p>
    Before we start using data structures in java we will need to learn one more aspect of the language. The import
    statement. We add our import statements before the beginning of the class definition for our program. In the
    upcoming lesson we will add <code>import java.util.ArrayList;</code> to give us access to the <a
        href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">ArrayList</a> class.
</p>
<p>
    There are many classes like ArrayList that are packaged with java, but must be added with an import statement to be
    used. Only classes
    in <a heref="https://docs.oracle.com/javase/7/docs/api/java/lang/package-summary.html">java.lang</a> are available
    by default as these classes have been determined to be so fundamental that every program should have immediate
    access to them. The rest of the classes must be imported to let the compiler know to load the
    additional classes. If a class is used without being imported the program will not run. For example if we attempt to
    use the ArrayList class without importing it first we will see the error <code>ArrayList cannot be resolved to a
    type</code>.
</p>


== Type Parameters

<p>
    When we crate a data structure in Java we must specify which type the data structure can store. This type must be a
    <a href="https://docs.oracle.com/javase/tutorial/java/concepts/class.html">class</a> and the data structure can only
    store objects of that class type. By java naming convention, if a type starts with a capital letter it is a class
    and if it starts with a lowercase letter it is a primitive. A primitive is a data type that only stores a value
    where an object can contain many values as well as methods. We have been using objects of type String throughout the
    course and we noticed that String starts with a capital S and we also have access to many methods by using the
    dot-operator on a String value.
</p>

<p>
    This sets up a big problem in that int, double, and boolean are all primitive types and therefor cannot be used as
    the type for data structures. This means we can never create a data structure that stores int, doubles, or boolean
    types. Luckily there is a very simple solution to this limitation by using wrapper classes.
</p>

<dl>
    <dt>Wrapper Class</dt>
    <dd>A class that can be used in place of a primitive type.</dd>
</dl>

<p>Instead of using the primitive types int, double, and boolean we will use the wrapper classes Integer, Double, and
    Boolean. These wrapper classes can be used <em>nearly</em> interchangeably with their primitive counterparts. Using
    these wrapper classes will allow us to store primitive values in data structures as well as give us access to a
    variety of methods that can be used in the same way as the String methods we've been using.
</p>

== ArrayList

<p>
    Armed with import statements and wrapper classes we are ready to use our first data structure, the ArrayList. An
    ArrayList is used to store multiple values of a provided type. The order of these values is preserved and their
    positions are indexed by integers starting at 0. This means the first value in an ArrayList is stored at index 0,
    the second at index 1, the third at index 2, and so on.
</p>
{#new keyword#}
{##}
{#Create a variable to store an ArrayList of a particular type.#}
{#Name the variable.#}
{#Create a new ArrayList of that type.#}
{#Store the new ArrayList in the variable.#}
{#-Do whatever we need to do with the ArrayList.#}
{##}
{#ArrayList#}

<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html">Javadocs: ArrayList</a>

{#Must have a type. It's a collection of values of that type.#}
{##}
{#Elements each have an index. Access data by its index. Indexing starts at 0.#}
{#(side note, we can get a char from a String by index. String is an array of char)#}


<hr/>
<h4>new</h4>
<p>
    To create an ArrayList, we can't simply give it a value. We must use the new keyword as well as specify the type
    parameter. Here we create a new ArrayList of Integers and name it listOfIntegers.
</p>
<pre>
        ArrayList&lt;Integer&gt; listOfIntegers = new ArrayList&lt;Integer&gt;();
        System.out.println(listOfIntegers);
</pre>

<p>
    Output: <kbd>[]</kbd>
</p>

<p>
    When we print the list we will see that it is empty.
</p>

<hr/>
<h4>add</h4>
<p>
    The add method will add an element to the end of an ArrayList. Using our list from the previous example we'll add 50
    to the end of the list.
</p>
<pre>
        listOfIntegers.add(50);
        System.out.println(listOfIntegers);
</pre>

<p>
    Output: <kbd>[50]</kbd>
</p>

<hr/>
<h4>get</h4>
<p>
    We'll also use the get method which returns a value at a particular index. Indexing in lists range from 0 to the
    number of elements minus 1.
</p>
<pre>
        System.out.println(listOfIntegers.get(0));
</pre>

<p>
    Output: <kbd>50</kbd>
</p>

<hr/>
<h4>size</h4>
<p>
    The size method returns the number of elements in the ArrayList.
</p>
<pre>
        System.out.println(listOfIntegers.size());
</pre>

<p>
    Output: <kbd>1</kbd>
</p>

<hr/>
<h4>contains</h4>
<p>
    Similar to the contains method for Strings, ArrayList has a contains method that returns true only if the element is
    in the list.
</p>
<pre>
        System.out.println(listOfIntegers.contains(50));
        System.out.println(listOfIntegers.contains(70));
</pre>

<p>
    Output: </p>
<kbd>true<br/>false</kbd>

<hr/>
<h4>Full Example</h4>


<pre>
import java.util.ArrayList;

public class DataStructureExample {

    static ArrayList&lt;Integer&gt; getList(){
        ArrayList&lt;Integer&gt; listOfIntegers = new ArrayList&lt;Integer&gt;();
        listOfIntegers.add(50);
        listOfIntegers.add(20);
        return listOfIntegers;
    }
    
    public static void main(String[] args){
        ArrayList&lt;Integer&gt; returnedList = getList();
        System.out.println(returnedList);
        System.out.println(returnedList.get(0));
        System.out.println(returnedList.get(1));
        System.out.println(returnedList.size());
    }
}
</pre>

<p>
    Output:
</p>
<kbd>[50, 20]<br/>50<br/>20<br/>2</kbd>

<p>
    This example shows everything we need to get started with ArrayList. Let's analyze this example one step at a time.
</p>
<br/>
<p>Breakdown:</p>
<ol>
    <li><code>import java.util.ArrayList;</code> Let the compiler know that we will use the ArrayList class</li>
    <li><code>ArrayList&lt;Integer&gt; returnedList = getList();</code> Control starts with the main method. In the
        first line we create a variable that can store an ArrayList of Integers, name it returnedList, and set it equal
        to the return value of the getList() method which has a return type of ArrayList&lt;Integer&gt;.
    </li>
    <li><code>getList()</code> To set the value of returnedList, the call to getList() must be resolved. There are not
        arguments or parameters to handle so control moves directly to the first line of the method.
    </li>
    <li><code>ArrayList&lt;Integer&gt; listOfIntegers = ...</code> Similar to the first line
        of main, we create a variable that can store an ArrayList of Integers and name it listOfIntegers.
    </li>
    <li><code>... = new ArrayList&lt;Integer&gt;();</code> Create a new instance of an ArrayList of Integers using the
        new keyword.
    </li>
    <li><code>listOfIntegers.add(50);</code> Add the value 50 to the end of the ArrayList. Since 50 is the first element
        added to the list it is placed at index 0.
    </li>
    <li><code>return listOfIntegers;</code> Return the ArrayList back to the main method.</li>
    <li><code>ArrayList&lt;Integer&gt; returnedList = getList();</code> Return to the main method and set the value of
        returnedList equal to the list returned from getList()
    </li>
    <li><code>System.out.println(returnedList);</code> Print the contents of returnedList in order "[50, 20]"</li>
    <li><code>System.out.println(returnedList.get(0));</code> Print the value at index 0 in the list "50"</li>
    <li><code>System.out.println(returnedList.get(1));</code> Print the value at index 1 in the list "20"
    </li>
    <li><code>System.out.println(returnedList.size());</code> Print the number of elements in the list "2"
    </li>
    <li><code>}</code> The end of the main method is reached and the program ends.
    </li>
</ol>


== HashMap


<a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">Javadocs: HashMap</a>

<p>
    Java's HashMap is similar to the ArrayList, except instead of indexing its values by sequential integers starting at
    0 the values are indexed by any type chosen by the programmer with no meaningful ordering. Thus when we store a
    value in a HashMap we must also provide an index value known as a key. We then call an element in a HashMap a
    key-value pair.
</p>

<p>
    As with ArrayList, we will need to import the HashMap class with <code>import java.util.HashMap;</code> before it
    can be used or we will see this error <code>HashMap cannot be resolved to a type</code>.
</p>

<hr/>
<h4>new</h4>
<p>
    Just like an ArrayList, we must use the new keyword to create a new instance of a HashMap. Since a HashMap need a
    type for its keys as well as it's values we must provide 2 types when creating a HashMap. The first type will
    specify the type for the keys and the second will determine the type of the values.
</p>
<pre>
        HashMap&lt;String, Integer&gt; mapOfStringsToDoubles = new HashMap&lt;String, Integer&gt;();
        System.out.println(mapOfStringsToDoubles);
</pre>

<p>
    Output: <kbd>{}</kbd>
</p>

<p>
    Here we have created a HashMap that maps String keys to Integer values and stored it in a variable named
    mapOfStringsToDoubles. When we print the map we see that it is empty. Let's add key-value pairs into the map using
    the put method.
</p>

<hr/>
<h4>put</h4>
<p>
    To insert key-value pairs into a HashMap we will call its put method. The put method takes 2 arguments. The first
    argument is the key and the second is the value to be stored. The types of these arguments must match the types of
    the HashMap.
</p>
<pre>
        mapOfStringsToDoubles.put("watch", 850);
        mapOfStringsToDoubles.put("luggage", 1099);
        mapOfStringsToDoubles.put("home theatre", 2100);
        System.out.println(mapOfStringsToDoubles);
</pre>

<p>
    Output: <kbd>{home theatre=2100, watch=850, luggage=1099}</kbd>
</p>

<p>
    Here we add 3 key-value pairs into the map print the map. Notice that when the map is printed the order is different
    that the order in which the values were inserted. Unlike ArrayLists, HashMaps do not store data in any meaningful
    order. We will get the values by providing their keys.
</p>


<hr/>
<h4>get</h4>
<p>
    To access the values in a HashMap we will call the get method with the key for the value as an argument.
</p>
<pre>
        int luggagePrice = mapOfStringsToDoubles.get("luggage");
        System.out.println(luggagePrice);
        System.out.println(mapOfStringsToDoubles.get("home theatre"));
</pre>

<p>
    Output: </p>
<kbd>1099<br/>2100</kbd>


<p>
    This allows us to access any of the stored data by providing the corresponding keys. In this case we want to store
    the prices of a variety of items. We don't want to memorize each price, but we do remember the items themselves.
    This makes it appropriate to store the prices as values and the item names as keys.
</p>

<p>
    Note: since the values are stored by their keys, a key can only appear in a map at most once. For example if we
    could put another home theatre into the map with a different price, which price would be returned when we call
    get("home theatre")?
</p>

<hr/>
<h4>size</h4>
<p>
    We can also get the number of key-value pairs stored in a HashMap we use its size method.
</p>
<pre>
        int numberOfEntries = mapOfStringsToDoubles.size();
        System.out.println(numberOfEntries);
</pre>

<p>
    Output: <kbd>3</kbd>
</p>

<p>
    Since we put 3 key-value pairs in this HashMap it will return 3 as its size.
</p>


<hr/>
<p>
    Putting the entire example together we have this program.
</p>

<pre>
import java.util.HashMap;

public class HashMapExample {

    static void example(){
        HashMap&lt;String, Integer&gt; mapOfStringsToDoubles = new HashMap&lt;String, Integer&gt;();
        System.out.println(mapOfStringsToDoubles);

        mapOfStringsToDoubles.put("watch", 850);
        mapOfStringsToDoubles.put("luggage", 1099);
        mapOfStringsToDoubles.put("home theatre", 2100);
        System.out.println(mapOfStringsToDoubles);

        int luggagePrice = mapOfStringsToDoubles.get("luggage");
        System.out.println(luggagePrice);
        System.out.println(mapOfStringsToDoubles.get("home theatre"));

        int numberOfEntries = mapOfStringsToDoubles.size();
        System.out.println(numberOfEntries);
    }

    public static void main(String[] args){
        example();
    }
}
</pre>

<p>
    Output: </p>
<kbd>{}<br/>{home theatre=2100, watch=850, luggage=1099}<br/>1099<br/>2100<br/>3</kbd>


== Iteration

<p>
    We now have 2 data structures that we can use to store and recall data, but what if we want to work with all the
    data in a data structure? In this lesson we will visit every element in a data structure using iteration.
</p>

<p>
    We already have the tools we need to iterate over an ArrayList by combining the size method, the get method, and a
    for loop.
</p>

<pre>
    static String charsToString(ArrayList&lt;Character&gt; inputList){
        // Concatenate all the Characters in the list into a single String.
        String result = "";
        for(int i=0; i&lt;inputList.size(); i++){
            result = result + inputList.get(i);
        }
        return result;
    }
</pre>

<p>
    In this method we are given an ArrayList of Characters, but we have no information about the list. To learn about
    the the ArrayList we will call its methods and use the return values in our code. First, we know we'll need a loop
    that run once for each element of the ArrayList so we will ask inputList to tell us its size and use this value to
    setup our loop. We carefully setup this loop so the index variable <code>i</code> will exactly match the index
    values of the ArrayList. This way we can call <code>inputList.get(i)</code> in the loop and know it will be called
    for every element of the list.
</p>

<p>
    We can create an ArrayList and call this method as follows:
</p>

<pre>
        ArrayList&lt;Character&gt; letters = new ArrayList&lt;Character&gt;();
        letters.add('l');
        letters.add('u');
        letters.add('c');
        letters.add('k');
        letters.add('y');
        String returnedString = charsToString(letters);
        System.out.println(returnedString);
</pre>

<p>Output: <kbd>lucky</kbd></p>

<p>
    When <code>charToString(letters)</code> is called in this example it will run the code in the method with letters as
    inputList. Then the method code is executed.
</p>

<pre>
    String result = "";
    for(int i=0; i&lt;inputList.size(); i++){
        result = result + inputList.get(i);
    }
    return result;
</pre>

<p>
    Since the inputList for this call contains 5 elements, its size method will return 5 and the code will become:
</p>

<pre>
    String result = "";
    for(int i=0; i&lt;5; i++){
        result = result + inputList.get(i);
    }
    return result;
</pre>

<p>
    Simplifying this loop will yield:
</p>

<pre>
    String result = "";
    result = result + inputList.get(0);
    result = result + inputList.get(1);
    result = result + inputList.get(2);
    result = result + inputList.get(3);
    result = result + inputList.get(4);
    return result;
</pre>

<p>
    Then accessing the elements of the list will result in the final code that will be executed.
</p>

<pre>
    String result = "";
    result = result + 'l';
    result = result + 'u';
    result = result + 'c';
    result = result + 'k';
    result = result + 'y';
    return result;
</pre>

<p>
    Showing 1 step further we can see how the String result is being constructed 1 character at a time.
</p>

<pre>
    String result = "";
    result = "" + 'l';
    result = "l" + 'u';
    result = "lu" + 'c';
    result = "luc" + 'k';
    result = "luck" + 'y';
    return "lucky";
</pre>

<p>
    This example shows how iterating over a data structure is accomplished. Next we will see a few more examples along
    with alternate syntax will be necessary to iterate over HashMaps which are not indexed in this predictable manner.
</p>

<hr/>

<p>
    Before we iterate over a HashMap, let's revisit Strings and explain something we've seen earlier in the course.
</p>

<pre>
    static String reverse(String input){
        // return the reverse of the string

        String reversed = "";
        for(int i=input.length()-1; i>=0; i--){
            reversed = reversed + input.charAt(i);
        }
        return reversed;
    }
</pre>

<p>
    Here we see how we can reverse a String using the tools we've seen earlier in the course. We are reversing the input
    String by iterating over its chars in reverse order while building a new String. This is very similar to the
    previous example except we don't use ArrayList and we iterate from the length of the String minus 1 to 0 instead
    from 0 to the length of the String minus 1.
</p>


== For-Each Loop

<p>
    We've seen that we can iterate over an ArrayList by relying on its values being indexed from 0 to size-1 making it
    possible to use the index of a for loop to access the elements, but how can we do this with keys in a HashMap that
    don't have to follow any convention? As the title suggests, we will use what's called a For-Each Loop.
</p>

<p>
    A For-Each Loop is a loop that executes once for each element in a given data structure and follows this syntax:
</p>

<pre>
    for([type] [name] : [dataStructure]){
        // Body of the loop
    }
</pre>

<p>
    We can rewrite the previous ArrayList example using a For-Each Loop to generate the same result, but without needing
    an index variable or calling the get method. The loop will automatically get each element, store it in a variable
    with the type and name we provide, and execute the body of the loop.
</p>

<pre>
    static String charsToStringForEach(ArrayList&lt;Character&gt; inputList){
        // Concatenate all the Characters in the list into a single String.
        String result = "";
        for(Character ch : inputList){
            result = result + ch;
        }
        return result;
    }
</pre>

<p>
    This For-Each Loop is read "For each Character ch in inputList, append ch to the end of result."
</p>

<br/>

<h3>keySet</h3>

<p>
    With the For-Each Loop we are prepared to iterate over the data in a HashMap using its keySet method. KeySet will
    return a Set containing all the keys contained in the HashMap. If we use this Set in a For-Each Loop, we can access
    all the data in the HashMap.
</p>

<p>
    Note: We can iterate over the <a
        href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.Entry.html">Entries</a> of
    a HashMap, but we have all the tools we need to access the data without having to explore this additional class.
</p>

<pre>
    HashMap&lt;String, Integer&gt; itemPrices = new HashMap&lt;String, Integer&gt;();
    itemPrices.put("watch", 850);
    itemPrices.put("luggage", 1099);
    itemPrices.put("home theatre", 2100);

    for(String item : itemPrices.keySet()){
        System.out.println("The " + item + " costs $" + itemPrices.get(item));
    }
</pre>

<p>
    Output: </p>
<kbd>The home theatre costs $2100<br/>The watch costs $850<br/>The luggage costs $1099</kbd>


<p>
    In this example we combine the For-Each Loop, the keySet method, and the get method to iterate over all the data in
    a HashMap. Recall that a HashMap does not preserve the order of its key-value pairs.
</p>

<hr/>
<h3>values</h3>

<p>
    In certain cases we are only concerned with the values in HashMap and want to bypass the keys entirely. In these
    situations we can use the values method which returns a Collection containing all the values that we can iterate
    through with a For-Each Loop.
</p>

<pre>
    HashMap&lt;String, Integer&gt; itemPrices = new HashMap&lt;String, Integer&gt;();
    itemPrices.put("watch", 850);
    itemPrices.put("luggage", 1099);
    itemPrices.put("home theatre", 2100);

    for(int price : itemPrices.values()){
        System.out.println("$" + price);
    }
</pre>

<p>
    Output: </p>
<kbd>$2100<br/>$850<br/>$1099</kbd>


{##}
{#keySet(): returns Set#}
{#values(): returns Collection#}

{#If we use these in for-each loops we treat these like ArrayLists.#}

{#Add all these ints.#}
{##}

{#== Databases#}
{##}
{#SQL? Too ambitious for transition 1?#}